//实现继承的方法有5种；
第一种是
1.扩展原型对象实现继承：在原型对象中通过点的方式直接添加属性、方法，比如有一个s1实例，那就相当于s1.prototype直接点属性或者方法添加。s1实例可以共享原型上的属性和方法
//对构造函数的原型对象直接通过点的方式添加属性或方法

2.替换原型对象实现继承：
//本来构造函数有一个默认的原型对象，现在通过新建一个原型对象的方式改变构造函数默认的原型对象
<替换掉构造函数默认的原型对象，>//新建一个原型对象，指向一个新的对象，在该对象中设置(constructor)、添加（多个）方法;  
 ---->因为如果要给实例添加很多个方法，一个一个往默认的原型对象添加很麻烦，

3.混入继承：将一个对象的属性和方法拷贝到另一个对象中，不能直接用对象等于对象的方式拷贝，要用for in遍历之前的对象属性来拷贝，这样对新的对象的操作不会影响之前对象的属性方法

4.原型+混入继承：将一个对象的属性和方法拷贝到原型对象中，只是拷贝到的目标变了，其他都一样，这样原型下的实例都能共享属性和方法

5.经典继承：其实和替换原型对象方法有点相似，就是先设置一个原型对象，然后创建另一个构造函数实例，这个实例就继承了原型对象的属性和方法
function create(o){
    	function F(){}
    	F.prototype=o;
    	return new F();
}

//事件冒泡和事件捕获

//事件冒泡：子元素上绑定的事件会一级一级往上冒泡，影响父元素的事件；然后事件冒泡是一直存在的
	解除冒泡就是对事件的默认e参数用e.stopPropagation就可以了！
//事件捕获：和事件冒泡刚好相反，事件捕获是往下的冒泡，影响子元素的事件
	有一个绑定事件的方法是addEventListener(event,handler,true),他有三个参数，最后一个参数为true则为事件捕获

